1->
Here i have to built a counter where i can increase and decrease it using buttons.
At first i create a contract and then for printing the the value of count i create a event and then two functions increment and decrement where i update 
value of counter and log the value of current count using emit log.
In this question i learned how to create contract,functions(variety of functions like public and all) and the use of event.

2->
Learning how to built profile or insert the info.Here i create a function with the parameter of string name and string bio i used "memory" for temproary
storage and also learned how to return something.

3->
I built a digital poll.Learned the concept of array and mapping.Create an array to store candidate detail and used mapping to maintain who vote for whom,
learn the new data type called address also learned about require used inside functions to make sure the if the given condition is true only then the function
will execute.View functions are only for read or return.

4->
Built digital auction.Learn the concepts like struct,blockchain time,if/else conditions. Used struct to store the name of the bidder name and amount he/she offers
and mapping to get and store the Bidder name and amount offers for each bids.One functions to store the end time of auction using timestamp(Global variable).
I also stored bidder addresses in an array to track all participants. Finally, I created a view function to loop through all bidders and return the highest
bid and bidder details. From this, I learned struct usage, mappings, array loops, input validation, view functions, and how to use timestamp for time-based
logic.     

5->
I built a contract where an owner controls a treasure chest. I learned how to use a modifier (onlyOwner) to restrict functions so only the owner can add 
treasure, approve users, and transfer ownership. I learned how msg.sender identifies who is calling the function, which allows access control and
ownership verification. I also learned how to manage permissions using mappings (approve, hasWithdrawn) so only approved users can withdraw and only
once. Finally, I learned how ownership can be updated to another address and how withdrawal logic works with validations using require. This helped me
understand admin-controlled smart contract design and permission-based interactions.

6->
I built a digital piggy bank where users can deposit and withdraw Ether. I learned how msg.sender identifies who is sending the transaction, and how 
to assign and track balances for each individual using a mapping from address to uint256. I also learned how to receive Ether using msg.value and how to
transfer Ether between addresses using transfer(). Additionally, I practiced using view functions to check balances without changing state. Overall,
this taught me how addresses hold funds, how deposits and withdrawals work, and how Ether is stored and managed inside smart contracts.

7->
I built a private IOU system where friends can deposit ETH, borrow from each other, and repay debts. I learned how to use nested mappings (like
debt[borrower][sender]) to track who owes who. I learned how payable allows real Ether to be handled inside functions and how balances are updated 
internally rather than using direct transfers. I also practiced using validation with require() to ensure correct borrowing and repayment logic. Overall, 
I learned how to model real-world lending relationships on-chain using addresses, mappings, and proper input validation.

8->
I created a multi-currency tip jar where users can tip in ETH, USD, or EUR. I learned how to use nested mappings to store contributions by both user and
currency. I also learned how to simulate currency conversion by storing conversion rates (usdToEth, eurToEth) and updating total ETH value accordingly.
I gained experience using payable and msg.value to receive real Ether, and restricting sensitive functions using ownership checks. This taught me how to 
handle multiple denominations and convert them, similar to a global tipping or donation system.


9->
I built two contracts where Contract A uses Contract B to perform arithmetic. I learned how contracts can call functions of another contract by converting 
an address into a contract instance using B calc = B(calcaddr). I also learned how to store another contract’s address and use it to access functions
externally. Additionally, I used an enum to represent different operations and applied require statements for validation. Overall, this taught me how 
smart contracts communicate with each other, how address casting works, and how to design modular systems where one contract depends on another.

10->
I built a fitness tracker contract where users log workouts and unlock achievements. I learned how to use events to broadcast important milestones and
how to make parameters indexed so external apps can easily filter logs by user or milestone. I practiced tracking user data using structs and mappings,
accumulating duration, workouts, and calories over time. I also used emitting events as goal notifications, which showed me how smart contracts interact
with off-chain listeners like front-end dashboards or analytics tools. Overall, I learned how to log activity, detect milestone achievements, and notify 
external systems using event-based architecture in Solidity.

11->
I built a secure vault system using inheritance. I learned how to create an Ownable base contract that defines the owner and the onlyOwner modifier, 
and then reuse it in VaultMaster using Solidity inheritance. This helped me understand how ownership and access control are implemented in real production
contracts. I also practiced restricting sensitive actions like withdrawals and ownership transfer so only the owner can execute them. Overall, I learned 
the Ownable pattern, how inheritance makes code cleaner and reusable, and how to enforce strong access control for smart contract security.

12->
I created my own digital token and learned the basic ERC-20 structure. I understood how total supply works and how balances are stored using a mapping.
I learned how to transfer tokens between addresses while validating balance using require. I also learned how to emit Transfer events, which is how real
tokens track movements on-chain. Overall, I learned the core token functions, token metadata (name, symbol, decimals), and how token balances are managed
like real cryptocurrencies.

13->
I learned how to sell my tokens for Ether by setting a fixed token price and calculating how many tokens a buyer receives based on ETH sent. I learned how
to store the remaining token supply and update it as purchases happen. I also understood how ETH accumulates inside the contract and how only the owner 
can withdraw it, demonstrating ownership control. This helped me understand token economics, pricing logic, and how smart contracts handle buying
operations securely using require conditions.

14->
I learned how to define and use interfaces for contract-to-contract interaction, allowing one contract to call functions in another in a structured and
safe way. I understood how abstraction works by separating the function definitions from the implementation. I also learned how ownership transfer is
implemented securely, and how a central manager contract can interact with different deposit types through a unified interface. This helped me understand
modular contract architecture, interoperability, and designing clean, scalable smart contract systems.

15->
I learned how to think about gas cost when writing smart contracts, especially how storage writes are expensive, while calldata and memory usage can
reduce gas fees. I understood how mapping for voter tracking prevents duplicate votes with minimal storage. I also learned how using an array for proposals
and updating only necessary fields reduces unnecessary on-chain data changes. Overall, I learned how to design smarter, lighter contract logic that saves
gas without sacrificing functionality.

16->
I learned how delegatecall allows executing plugin logic in the context of the main contract, meaning all state changes affect the player's core profile 
rather than the plugin contract. I understood how modular architecture makes contracts upgradable by adding new feature contracts without redeploying the
core logic. I also learned how execution context and storage layout matter when calling external logic, and how plugins like Achievements, Inventory, 
and BattleStats can be attached dynamically to a player profile. Overall, I learned how to build extensible and upgradeable smart systems similar to 
addon systems in games.

17->
I learned how upgradeable contracts separate data from logic using the proxy pattern. I understood how the proxy stores the persistent state while logic
contracts can be replaced over time without losing subscription data. I learned how delegatecall executes external logic in the proxy’s storage context,
enabling updates while preserving user states like plans and expiries. I also learned how to migrate functionality by deploying new versions like V2 with 
more features, while users still interact through the same proxy contract address with uninterrupted service.

18->
I learned how smart contracts can fetch real world off chain data using oracles like Chainlink. I now understand that Ethereum itself cannot access 
external data directly, so we rely on oracle interfaces to securely retrieve real-time information such as rainfall levels. I learned how to build logic
that uses this data to trigger real-world financial outcomes — in this case, insurance payouts to farmers when rainfall is below a threshold. This helped 
me understand oracle integration, external data verification, and how blockchain can interact with real-world events.

19->
I learned how authentication can be done using signatures instead of storing on-chain whitelists, which saves a lot of gas. I understood how to use
ecrecover to verify that a message was signed by a trusted organizer, allowing guest identity verification without prior on-chain data. I also learned 
how hashing works with signed messages, how Ethereum prefixes signed payloads, and how to extract signature parameters (r, s, v) using assembly. 
Overall, I learned how off-chain approvals can securely authenticate users on-chain in a privacy-efficient and gas-optimized way.

20->
I learned how reentrancy attacks can drain funds if withdrawals happen before balances update, and how to prevent them using the nonReentrant modifier
with a locked state. I understood why updating balances before transferring ETH is critical for security. I also learned how to properly send ETH using
low-level call, and how to structure functions to avoid recursive malicious calls. Overall, I learned secure vault logic, state-locking, and best
practices for preventing reentrancy vulnerabilities in withdrawal mechanisms.

21->
I learned how NFTs work by implementing ERC-721 basics each token is unique and linked to a specific owner. I learned how the mint function creates a 
new NFT with a unique ID and metadata, and how ownership is tracked using mappings. I also understood how transfers work between users and how metadata
strings (like image URLs or JSON data) are stored for each NFT. Overall, I learned how to create, store, and transfer unique digital collectibles on-chain.

22->
I learned how to create a basic lottery where users enter by paying a fee and a random winner is selected. I understood how random numbers can be generated
using hashing (though not fully secure), and how to store players in an array and distribute the winnings to a selected address. I also learned how access
control works by restricting certain actions only to the manager. This helped me understand randomness, lottery logic, and value transfers in smart contracts.


23->
This contract acts like a crypto bank where users can deposit money, provide collateral, borrow funds, and repay loans with interest. It tracks each user’s
deposits, borrow amount, collateral, and borrowing time. Before borrowing, users must provide collateral worth at least half of the borrowed amount.
Interest increases over time based on how long the loan is kept. Users can later repay the loan plus interest, and they can also withdraw their deposited
amount anytime.

24->
Built a secure Escrow system for conditional payments. I learned how to handle multi-party approval and dispute resolution. I used constructor to 
initialize buyer, seller, arbiter, and initial deposit. The approveRelease() function allows both buyer and seller to approve the transaction, and only 
when both agree, the funds are released using releaseFunds(). I learned to use require to restrict access (only buyer/seller/arbiter can call certain
functions). The raiseDispute() function allows either party to mark a conflict, and resolveDispute() allows the arbiter to decide who gets the money.
I also learned to write view functions (like getDetails()) to return data without modifying state. Through this, I understood escrow service logic, 
conditional payments, multi-party approval tracking, and dispute handling in smart contracts.

25->
Built a token-trading system using AMM (Automated Market Maker) logic. I learned how liquidity pools work and how prices are determined using the 
constant-product formula. The addLiquidity() function increases the reserve of tokens and tracks the liquidity provider. The getPrice() function 
calculates output tokens using the AMM formula, showing how trades affect price. The swapAtoB() and swapBtoA() functions execute token swaps by updating
reserves and transferring the respective output tokens. I understood how token reserves dynamically change and how price is affected by the size of trade
relative to liquidity (slippage). Also learned how view functions like getReserves() return pool info without modifying state. This helped me understand 
real DEX mechanics (like Uniswap), AMM pricing, liquidity contribution, and constant-product market behavior.

26->
Built an NFT marketplace for listing and selling NFTs. I learned how NFTs are transferred using transferFrom() via an interface and how ownership works
using ownerOf(). The contract uses a Listing struct to store all NFT sale details including seller, NFT contract address, tokenId, price, and royalty
percentage. The listNFT() function creates a sale listing and stores it in the contract, and I learned how mappings and incremental IDs (nextId) allow 
tracking of multiple listings.

The buyNFT() function handles the purchase logic: I learned how royalties are calculated, split payments between seller and creator, and how NFTs are safely
transferred to the buyer using the interface. I also learned how to deactivate listings after purchase by setting active = false.

The cancelListing() function allows sellers to remove their listings, teaching access control (only seller can cancel). The getListing() function shows how
to return structured data using a view function without modifying state.

From this, I learned how NFT marketplaces work, how token transfers are handled, how royalties are enforced in smart contracts, and how
listing/marketplace logic is structured in Web3 applications.

27->
I learned how staking works and how to calculate time-based rewards for users who lock their tokens.
stake() — lets users deposit tokens for staking and updates their stored rewards.
calculateReward() — calculates reward based on how long tokens were staked and the reward rate.
claimReward() — user claims only the rewards without withdrawing stake.
withdraw() — user removes some or all staked tokens and also receives rewards.
getUserData() — view function to check stake amount, rewards, and timestamp.
setRewardRate() — only owner can change the global reward percentage.

28->
In this DAO governance contract, I learned how decentralized decision-making works using token-based voting. I understood how proposals are created with 
deadlines, and how voting is weighted by the number of governance tokens each member holds. The createProposal function allows members to submit proposals,
while vote records their choice and ensures they cannot vote twice using a mapping. I also learned how executeProposal finalizes the outcome after the 
voting period and how mintTokens lets the owner distribute voting power. Overall, this contract taught me the structure of a DAO, the concept of token-driven
governance, and how time-restricted voting ensures fairness in decentralized systems.

29->
In this Stablecoin contract, I learned how a crypto token can maintain a stable value using real collateral as backing. The depositCollateral function 
showed me how users lock ETH and receive stable tokens in return—demonstrating how supply is created through collateralization. The redeem function allowed
users to burn their tokens and withdraw the equivalent collateral, showing how stability and trust are maintained. I also learned how the owner can adjust
the peg value with adjustPeg, which mimics real-world price-stability controls. Additionally, functions like transfer taught me fundamental token movement,
and getTokenValueInCollateral helped me understand how value conversion works between tokens and underlying collateral. Overall, this contract taught me 
stablecoin mechanics, collateral management, token minting/burning, and maintaining value stability through pegging.

30->
In this SimpleDEX contract, I learned how a basic decentralized exchange works by using liquidity pools instead of traditional order books. The addLiquidity
function showed me how users can deposit two tokens to create trading reserves, while getPriceAtoB calculates swap values based on current reserve ratios.
The swapAtoB function demonstrated token swapping logic where a user sends token A and receives the equivalent amount of token B using pool pricing. I also
learned how withdrawLiquidity lets the owner remove tokens from the reserves and how reserve tracking is critical for price stability. Overall, this contract
helped me understand token swaps, liquidity management, and the foundational logic behind decentralized exchanges like Uniswap.